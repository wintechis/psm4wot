@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix td: <https://www.w3.org/2019/wot/td#> .
@prefix jsonschema: <https://www.w3.org/2019/wot/json-schema#> .
@prefix schema: <http://schema.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix vann: <http://purl.org/vocab/vann/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix : <https://ex.com/> .

<https://ex.com/> a owl:Ontology ;
    vann:preferredNamespacePrefix "spa" ;
    vann:preferredNamespaceUri "https://paul.ti.rw.fau.de/~jo00defe/spa#" ;
    owl:versionInfo "0.0.1" ;
    rdfs:comment "Ontology to model preconditions and effects of actions in a Thing Description."@en ;
    dcterms:title "Simple Planning Annotation"@en ;
    dcterms:license <http://purl.org/NET/rdflicense/cc-by4.0>  ;
    dcterms:contributor <https://freumi.inrupt.net/profile/card#> ;
    dcterms:author "Christoph Stade" .

# Mathematical expressions Ontology

# :NumericDivide a rdfs:Class;
#     rdfs:subClassOf :NumericOperator ;
#     rdfs:label "NumericDivide" ;
#     rdfs:comment "Evaluates to the arithmetic quotient of its two operands."@en ;
#     rdfs:seeAlso "https://www.w3.org/TR/xpath-functions-31/#func-numeric-divide" ;
#     rdfs:isDefinedBy <https://paul.ti.rw.fau.de/~jo00defe/spa> .


:Expression a owl:Class . # Synonym Term

:BooleanExpression a owl:Class ;
    rdfs:subClassOf :Expression .

:NumericExpression a owl:Class ;
    rdfs:subClassOf :Expression .

:BooleanOperand a owl:Class ;
    rdfs:subClassOf :BooleanExpression .
:BooleanOperator a owl:Class .

:NumericOperand a owl:Class ;
    rdfs:subClassOf :NumericExpression .
:NumericOperand a owl:Class .

:hasBooleanOperand a rdf:Property ;
    rdfs:domain :BooleanExpression ;
    rdfs:range :BooleanOperand .

:hasNumericOperand a rdf:Property ;
    # schema:domainIncludes :NumericOperator, :ComparisonOperator ; # muss man nochmal schauen... domainIncludes schlecht (superklasse wahrscheinlich)
    rdfs:domain :NumericExpression ;
    rdfs:range :NumericOperand .

:hasBooleanOperator a rdf:Property ;
    rdfs:domain :BooleanExpression ;
    rdfs:range :BooleanOperator .

:hasNumericOperator a rdf:Property ;
    rdfs:domain :NumericExpression ;
    rdfs:range :NumericOperator .

:hasComparisonOperator a rdf:Property ;
    rdfs:domain :NumericExpression ;
    rdfs:range :ComparisonOperator .

:Numeral a rdfs:Class ; 
    rdfs:label "Numeral" ;
    rdfs:comment "Container class to bundle all numeric XMLSchema datatypes."@en ;
    rdfs:isDefinedBy <https://paul.ti.rw.fau.de/~jo00defe/spa> ;
    rdfs:subClassOf xsd:simpleType ;
    rdfs:subClassOf :NumericOperand .

xsd:float rdfs:subClassOf :Numeral .
xsd:double rdfs:subClassOf :Numeral .
xsd:decimal rdfs:subClassOf :Numeral .
# xsd:boolean rdfs:subClassOf xsd:simpleType .
xsd:boolean rdfs:subClassOf :BooleanOperand .



# Wie unterscheide ich 
#     Term der zu Typ A ausgewertet wird und 
#     Term der Typ B als Operanden nimmt

#     bool/bool
#         -> bool/bool
#     num/num
#         -> num/bool
#         -> num/num
#     num/bool
#         -> bool/bool

! Maxime:
   BooleanExpression -> wertet zu Boolean aus
   BooleanOperator -> nimmt nur Bools 
        (kann ich das mit Shacl ausdruecken?? wenn ein BooleanExpresssion einen BooleanOp hat muessen die hasOperator bools sein??
        Abhaengigkeit in die Parent Class reinbekommen)





# # TODO: Conditions: https://technicalbuildingsystems.github.io/Ontologies/ExpressionOntology/index-en.html#Expression
# # https://www.w3.org/TR/xpath-functions-31/#func-numeric-divide

# :Equality a owl:Class ;
#     rdfs:subClassOf :Condition ;
#     rdfs:subClassOf [
#         # Wenn ich ein VariableSet instanziieren moechte, brauche ich mindestens eine Transition
#         a owl:Restriction ;
#         owl:onProperty :hasParameter ;
#         owl:QualifiedCardinality "2"^^xsd:nonNegativeInteger ;
#         owl:onClass :Variable .
#     ] .

# :Constant a rdf:Class ;
#     rdfs:subClassOf :Condition ;
#     rdfs:subClassOf [
#         # Wenn ich ein VariableSet instanziieren moechte, brauche ich mindestens eine Transition
#         a owl:Restriction ;
#         owl:onProperty :hasParameter ;
#         owl:QualifiedCardinality "1"^^xsd:nonNegativeInteger ;
#         owl:onClass :Variable .
#     ] .


# => Vllt kann es auch keine ALLGEMEINE Mathe Onlogie werden, wegen den bereites existierenden
#     SONDERN nur wieder eine MAPPING Ontologie aus gegebenen Anforderungen

# Open-Math RDF encodings sieht eigl relativ stabil aus...
#   finde ich genuegend Argumente, die Ontologie neu zu machen ?? (SHACL...)
#   - lesbarkeit in TD: mapping geht nicht wenn ich Platzhalter verweise per link hab, brauche explizite vocabel elemente pro operation

# OntoMathPro 2.0
#   - auf russisch??!
#   - links auf wikipedia....

#     ! Es gibt mit Sicherheit noch keine SHACL Mathe Ontologie





#    RDF* auch interessant, dann Refifiziertes Tripel als Ergebnis wieder als Operand
#    -> "In Table XY you can see an alternative of modeling terms in RDF*, but we focus on regular RDF because... not widely supported..."
#    (Als Alternative zur Term Klasse)



# - OWL restriction exklusives ODER (BooleanOperator, BooleanComparison)
#         https://ceur-ws.org/Vol-216/submission_9.pdf
#         3.3 Exclusive OR
#         https://www.w3.org/TR/owl-ref/#complementOf-def
#         https://github.com/dbpedia/ontology-tracker/blob/1d9431899a631ec8e25e27b0f9d69c1d0903e9b7/ontologies/purl.org/part/v1.0/2008-09-25.n3#L103
#         superklasse
#           mit disjunkten subklassen



"
    in fact, there are projects for encoding OpenMath
    documents as LOD-integrated RDF datasets [6], [7]. These encodings however
    represent math statements only indirectly: they assert statements about Open-
    Math documents, not the math statements themselves.
"


Eher ueber rdf:Collection gehen mit first und rest bei den Argumenten 
   dann spar ich mir die ganzen Datentypen-Versionen von hasOperand
     Die Einschraenkung was von welchem Typen bei welcher Auswertung zu verwenden dann ueber SHACL
      -> generisches https://openmath.org/cd/relation1 equal andhand eines Operanden die anderen Einschraenken

! Aber es fehlt in OpenMath zu welchem Datentyp die Operatoren auswerten -> vllt im TDMapper ergaenzen (Assignment vs. Guard)


